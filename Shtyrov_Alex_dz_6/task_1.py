"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
from memory_profiler import profile


@profile
def func_1():
    num = [i for i in range(10000)]
    new_arr = []
    for i in range(len(num)):
        if num[i] % 2 == 0:
            new_arr.append(i)
    del num
    return new_arr


@profile
def func_2():
    num = [i for i in range(10000)]
    new_arr = [i for i in range(len(num)) if num[i] % 2 == 0]
    del num
    return new_arr


@profile
def func_3():
    num = [i for i in range(10000)]
    new_arr = []
    i = 0
    for el in num:
        if el % 2 == 0:
            new_arr.append(i)
        i += 1
    del num
    return new_arr


func_1()
func_2()
func_3()

# В данном случае профайлер не находит
# разницы в объеме используемой памяти функций,
# тут меняется только скорость выполнения. В данном
# случае, разве что можно удалить изначальный список num после
# получения результата в функции. Конечно, не лучший пример для
# демонстрации получился, но суть я понял.

